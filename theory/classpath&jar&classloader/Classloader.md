https://javarush.com/groups/posts/646-kak-proiskhodit-zagruzka-klassov-v-jvm 

Согласно спецификации Java SE для того, чтобы получить работающий в JVM код, необходимо выполнить ***три этапа***:

1. загрузка байт-кода из ресурсов и создание экземпляра класса Class

сюда входит поиск запрошенного класса среди загруженных ранее, получение байт-кода для загрузки и проверка его корректности, создание экземпляра класса Class (для работы с ним в runtime), загрузка родительских классов. Если родительские классы и интерфейсы не были загружены, то и рассматриваемый класс считается не загруженным.

2. связывание (или линковка)

по спецификации этот этап разбивается еще на три стадии:

  - 2.1 Verification, происходит проверка корректности полученного байт-кода.
  - 2.2 Preparation, выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (при этом явная инициализация, если она есть, происходит уже на этапе инициализации).
  - 2.3 Resolution, разрешение символьных ссылок типов, полей и методов.

3. инициализация полученного объекта

![Loading](https://github.com/ArthurYasak/JavaTheory/blob/3c7933f4e7cca00ea7003ae1442bc78ed4ea004f/images/classpath%26jar%26classloader/Loading.png)
Источник: https://medium.com/@wakefulinsomnia/how-does-java-classloader-system-work-82eaf378f73b

### Типы загрузчиков Java
В Java существует три стандартных загрузчика, каждый из которых осуществляет загрузку класса из определенного места:
- Bootstrap – базовый загрузчик, также называется Primordial ClassLoader.

загружает стандартные классы JDK из архива rt.jar, загружает основные библиотеки Java, расположенные в папке <JAVA_HOME>/jre/lib

- Platform (Extension) ClassLoader – загрузчик расширений.

загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dirs

- Application (System) ClassLoader – системный загрузчик.

загружает классы приложения, определенные в переменной среды окружения CLASSPATH.
Именно этот загрузчик подгружает ваши собственные реализации и библиотеки зависимостей, которые вы передали JVM (явно или неявно) при старте приложения в качестве -classpath (-cp) параметра.

В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. 
Каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.

### Три принципа загрузки классов
- Делегирование

Запрос на загрузку класса передается родительскому загрузчику, и попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик 
не смог найти и загрузить класс. Такой подход позволяет загружать классы тем загрузчиком, который максимально близко находится к базовому. 
Так достигается максимальная область видимости классов. Каждый загрузчик ведет учет классов, которые были загружены именно им, помещая их в свой кэш. 
Множество этих классов и называется областью видимости.

- Видимость

Загрузчик видит только «свои» классы и классы «родителя» и понятия не имеет о классах, которые были загружены его «потомком».

- Уникальность

Класс может быть загружен только однажды. Механизм делегирования позволяет убедиться, что загрузчик, инициирующий загрузку класса, не перегрузит 
загруженный ранее в JVM класс.

Таким образом, при написании своего загрузчика разработчик должен руководствоваться этими тремя принципами.

## Схема загрузки классов
Когда происходит вызов загрузки какого-либо класса, происходит поиск этого класса в кэше уже загруженных классов текущего загрузчика.

Если желаемый класс еще не загружался ранее, по принципу делегирования управление передается родительскому загрузчику, который находится по иерархии на уровень выше. Родительский загрузчик также пытается найти желаемый класс у себя в кэше. Если класс уже был загружен и загрузчик знает о его местонахождении, то будет возвращен объект Class этого класса. Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика. Если и в базовом загрузчике нет информации об искомом классе (т.е. он еще не был загружен), будет выполнен поиск байт-кода этого класса по расположению классов, о котором знает данный загрузчик, и, если загрузить класс не удастся, 
управление вернется обратно загрузчику-потомку, который будет пытаться выполнить загрузку из известных ему источников. Как уже упоминалось выше, расположение классов для базового загрузчика это библиотека rt.jar, для загрузчика расширений – каталог с расширениями jre/lib/ext, 
для системного – CLASSPATH, для пользовательского это может быть что-то свое.

Таким образом, ход загрузки классов идет в обратном направлении - от корневого загрузчика до текущего. Когда байт-код класса найден, 
происходит загрузка класса в JVM и получение экземпляра типа Class.

https://habr.com/ru/articles/748758/
